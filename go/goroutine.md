1. 먼저 고루틴과 Thread 차이는 무엇일까
- 메모리 소비
  - jvm은 기본적으로는 스레드를 활용하는데 스레드당 스택 및 guard page를 위해 1mb 정도가 필요하다
  - 고루틴은 2kb + 필요에 따라 힙 영역 활용
- 설치와 철거 비용
  - 스레드는 `os`로부터 리소스를 요청해야하고 돌려줘야하기 때문에 설치와 철거 비용이 상당히 큰 자원이다.
  - 반면 고루틴은 `runtime`에서 만들어지고 제거되는 작업으로 매우 저렴하다.
- Context Switching 비용
  - 만약 특정 스레드가 blocking 당한다면, 다른 스레드가 그 자리를 대체해야한다.
  - 즉 다른 스레드로 스케줄링 되어야하는데, 이를 위해선 스케줄러는 context switch를 위해 모든 레지스터들을 save/restore해야한다.
  - 고루틴의 경우 단 3개의 레지스터만 save/restore 하기 때문에 비용이 굉장히 저렴하다
    - program counter, stack pointer, DX
```
고루틴은 M:N 스레드 모델을 사용한다.
```
### 고루틴
- 고루틴 : Go runtime환경에서 동작하는 쓰레드보다 굉장히 가벼운 실행 조각이다. 초기에 생성할 때 2KB의 매우 작은 스택 크기만을 필요로 하며 가지고 있는 레지스터도 프로그램 카운터(PC)와 스택 포인터(SP) 정도가 전부이다
- 고랭 동시성 모델의 기원 : 공유 메모리를 사용하지 않고 channel을 통해 데이터를 공유해서 뮤텍스, 세마포어를 사용하지 않는다.
- ![image](https://github.com/user-attachments/assets/b9761d93-9e5b-491c-920b-0d021359ae8f)

```
G : goroutine
M : machine (os thread)
P : Processor, 스케줄링에 대한 context 

---------------
G -> P -> M 연결
G와 P 연결
- 고루틴 G는 P의 실행 큐에 배치됩니다.
- P는 실행 큐에 있는 G를 M에게 할당합니다.

P와 M 연결
- P는 논리적 프로세서로 M과 연결되어야만 고루틴을 실행할 수 있습니다.
- P는 자신이 관리하는 고루틴 큐에서 실행할 고루틴을 꺼내 M에 전달합니다.
- 즉 프로세서는 고루틴(작업)을 관리(스케줄링)하지만 이를 실제 수행하기 위해 M이 필요하고 이것이 m-p가 연결되는 이유다.

M의 역할
- M은 운영 체제의 스레드로, P를 통해 전달받은 고루틴을 실행합니다.
- M이 차단되거나, 시스템 호출로 인해 블로킹 상태가 되면 Go 런타임은 새로운 M을 생성하거나 기존 M을 재사용합니다.
```

- Go 런타임 스케줄러
  - 고루틴은 Go runtime에 포함되어 있는 Golang Scheulder가 실행하는 쓰레드 스케쥴링에 의해서 실행된다
  - ![image](https://github.com/user-attachments/assets/72b571ef-7720-44ca-8873-a8397310b85c)

① (LRQ) 프로세서 P는 내부의 로컬 실행 큐 (Local Run Queue)를 가지고 있는데 큐에는 실행 가능한 고루틴이 저장되어 있다. M은 프로세서 P의 작업 큐를 가져와서 순차적으로 실행하게 된다.

② (GRQ) Global Run Queue는 LRQ에 속해있지 않은 고루틴이 저장되게 된다. 고루틴은 최대 10ms 까지 동작한다. 10ms가 지난 후에는 대기 상태에 들어가 GRQ에 들어가게 된다. 
만약 하나의 P의 LRQ가 다 소진된다면 P는 먼저GRQ로부터 고루틴을 가져오고 GRQ도 비어있다면 다른 P의 LRQ로부터 작업을 뺏어온다(Work Stealing).

③ (Scheduling) 원래 고 런타임 스케쥴러는 일정 시간 마다 작업을 중단하는 선점 스케쥴링(Preemptive Scheduling) 방식이 아니라 
작업 하고싶은대로 다 한다음에 쓰레드 사용 할 자리를 넘겨주는 협력적 스케쥴링(Cooperative Scheduling) 방식이었다. 
Go 1.14[5] 에서 선점 스케쥴링 개념이 추가되었는데 기존 고루틴에서 연산이 오래걸리는 작업을 할당해두면 GC가 계속 딜레이 되어서 10ms 제한 규칙을 추가했다고 한다. 
Go 언어에서 GC는 최대 가능하면 10ms 이내에 끝내도록 하기 때문에 GC가 자주 수행되도록 변경되었다. 

④ (왜 Processor P가 필요한가?) : 
- 지역성을 부여하기 위해서인데 동일한 프로세서 생성된 고루틴은 같은 프로세서에 할당되어 실행되는게 좋다. 그 이유는 캐시 때문에 Lock을 들고 있지 않아도 된다고 한다.
- 쓰레드는 어떠한 이유에서든 Blocking될 수 있는데 이 때 쓰레드에서는 어떠한 코드도 실행되지 않기 때문에 LRQ 에 있는 고루틴들이 계속 대기상태에 빠지게 된다. 따라서, 실행 컨텍스트를 다른 쓰레드에게 넘겨주기 위해서 논리적 개념인 P를 도입했다

![image](https://github.com/user-attachments/assets/5c0324ef-e339-4e6f-9a7f-17c0ba47ba2e)
⑤ (Sync/Async System Call) 시스템 콜은 동기/비동기 방식으로 동작할 수 있다. 예를 들어 파일-시스템 같은 경우에는 대부분 동기방식으로 동작하고 네트워크 I/O 같은 경우에는 비동기 방식으로 동작한다. 만약 고루틴이 비동기 시스템 콜을 발생시키고 대기 상태에 들어간 경우에는 이를 독립된 쓰레드인 Net poller에서 관리한다. Net poller는 비동기 시스템 콜이 작업이 끝났다는 이벤트를 수신하고 이를 다시 LRQ에 넣어서 실행될 수 있도록한다. 이렇게 Net poller를 별도로 분리해서 이미 P와 연관된 쓰레드 M이 재사용될 수 있도록한다. 반면, 동기 시스템 콜의 경우에는 쓰레드도 같이 블럭킹 시키기 때문에 G와 M을 같이 묶어서 블럭킹 시키고 새로운 M을 생성해서 P에 연관시킨다
