1. go GC
- go는 사용자가 직접 메모리를 관리하지 않도록 설계되어있다.
- 하지만 물리 메모리는 한정된 자원이고 효율적으로 사용하기 위해선 효율적인 할당과 해제, 재활용이 필요하다
- 따라서 GC가 필요하다
2. gc가 관리하지 않는 메모리
- 포인터가 아닌 값이 local variable에 저장되는 경우
  - 이 경우 고루틴의 스택을 활용한다.
  - 스택은 결국 함수와 생명주기를 함께 하기 때문에 컴파일러가 메모리 해제 시점을 사전에 결정할 수 있다.
  - 그렇기 때문에 메모리 할당과 해제 작업이 간단해진다
3. gc가 관리하는 메모리
- gc가 관리하는 메모리는 힙 영역에 저장되는것들
  - 메모리 할당과 해제 시점을 예측할 수 없는 것들
  - ex. 크기가 동적으로 결정되는 슬라이스의 배열 등.
  - ex. 이미 힙에 저장된 객체에 포인터로 참조되는 값.
  - 이러한 것들은 gc가 주기적으로 관찰하고 해제해야한다.
- 힙 메모리 영역은 결국 해제 시점이 명확하지 않으니 주기적으로 관찰해야하고 이게 성능에 영향을 미친다.
  - 다시 말하면 과도한 포인터 사용이 성능에 악영향을 줄 수 있고, 스택 메모리 사용이 좋은 경우도 있다는것
- 참고로 컴파일러는 걊이 스택에 남아도 되는지 Escape Analysis를 통해 힙으로 옮길지 결정한다
```
func example() *int {
    i := 42       // 스택에 할당될 가능성이 큼
    return &i     // i는 함수의 스코프를 벗어나므로 힙에 할당
}
```

