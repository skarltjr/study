1. go에는 참조 타입이 존재한다.
- map, slice, channel, interface
- 참조 타입이란 메모리 주소에 대한 데이터를 갖고 있고 그렇기에 값을 복사하더라도 복사된 값이 결국 특정 메모리 주소에 대한 값이다.
  - call by value로 기본 동작하지만 reference type에 대해 원본 값이 변경되는 이유다.


2. array
- 값 타입: 배열은 값 타입입니다. 즉, 배열을 변수에 할당하거나 함수에 전달할 때 배열 전체가 복사됩니다.
- 크기가 타입에 포함: 배열의 크기는 타입의 일부입니다. 예를 들어 [3]int와 [4]int는 서로 다른 타입으로 취급됩니다.
- 고정 크기: 배열은 선언 시 크기를 지정해야 하며, 크기를 변경할 수 없습니다.
```
func main() {
	asd := [3]int{1, 2, 3}

	hello(asd)
}

func hello(a [3]int) {
	a[0] = 100
}
```
- golang은 기본적으로 call by value
- 파라미터로 배열을 넘길땐 값을 복사하여 전달하고, 원본 데이터의 변화가 없다.

3. slice
- 배열의 래퍼: 슬라이스는 배열 위에 정의된 동적 데이터 구조입니다.
- 참조 타입: 슬라이스는 배열의 "참조"를 저장하며, 슬라이스를 다른 변수에 할당하거나 함수에 전달해도 배열 자체는 복사되지 않습니다.
- 길이와 용량: 슬라이스는 배열의 일부를 참조하므로, 길이(len)와 용량(cap) 개념이 따로 존재합니다.
  - 길이(len): 슬라이스가 현재 사용할 수 있는 요소의 개수.
  - 용량(cap): 슬라이스가 참조할 수 있는 배열의 최대 요소 개수

```
func main() {
	asd := []int{1, 2, 3}

	hello(asd)
	print("qwe")
}

func hello(a []int) {
	a[0] = 100
}
```
- slice는 기본적으로 배열의 "참조"를 저장한다.
- 파라미터로 넘겨진 slice 자체가 배열의 참조를 저장하고 있고 이 값이 복사되어 넘어가는것으로 원본 데이터가 변경된다.

4. map
- 맵은 하나의 타입을 다른 타입에 매핑
- 키는 다양한 타입이 될 수 있으며, 해당 타입에 대해 동등성 비교(==) 연산자가 정의되어 있어야만 맵의 키로 사용할 수 있다.
  - 예를 들어, 정수, 문자열, 포인터, 구조체 등은 키로 사용할 수 있지만, 슬라이스는 동등성 비교가 정의되지 않아서 키로 사용할 수 없습니다.
- 참조 타입: 맵은 참조 타입이므로, 맵을 함수에 전달하면 그 함수에서 맵의 값을 수정할 수 있습니다. 함수에서 수정된 맵의 값은 호출자에게 반영됩니다.
- 동적 크기: 맵은 동적으로 크기를 조정할 수 있으며, 새로운 키-값 쌍을 추가하거나 삭제할 수 있습니다.


