1. Go is a compiled, concurrent, garbage-collected, statically typed language developed at Google.
2. The first step to making Go scale, go는 컴파일 시점에 종속성 에러를 잡아낸다.
3. go의 컴파일이 빠른 이유
```
package A imports package B;
package B imports package C;
package A does not import package C
```
- A는 B를 import 하지만 C에 대해 모른다
- A가 컴파일될때 B의 소스 코드가 아니라 B의 object file을 읽는다.
  - B의 object file은 B가 import하고 있는 C의 정보가 모두 담겨 있다는것이다
  - 이를 위해선 C가 먼저 컴파일 되고, B, A 순으로 진행된다.
- 중요한건 컴파일러가 소스코드가 아닌 object file(exported data)를 읽는다는것이다.
  - 참조하는 전체 소스코드를 읽고 파싱하는 과정이 없으니 빠르다.
  - 그리고 object file에 exported data가 담겨있으니 별도로 다시 exported data를 읽기 위한 file이 필요하거나 하지 않다.
- 또한 순환 참조가 없다.
4. 동시성
- go는 csp(communicating sequential processes) 모델을 활용한다.
  - 이 모델은 프로세스간에 메세지를 주고 받는식으로 동시성을 해결
  - go에서는 channel을 활용
  - 이를통해 얻는 이점은 전통적인 공유 메모리 접근 방식에 비해 race condition을 최소화
- 기본적으로 csp 모델을 활용하고 동시성 작업에서 메모리 안정성을 제공하지만, 그렇다고 완전한 메모리 안정성을 제공하진 않는다
  - 즉 잘못된 방식을 막진 않는다.
  - 예를들어 채널을 통해 포인터를 전달할 수 있는데 원본 값의 변경이 동시에 여러 곳에서 가능하다는것
