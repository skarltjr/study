1. go GC
- go는 사용자가 직접 메모리를 관리하지 않도록 설계되어있다.
- 하지만 물리 메모리는 한정된 자원이고 효율적으로 사용하기 위해선 효율적인 할당과 해제, 재활용이 필요하다
- 따라서 GC가 필요하다
2. gc가 관리하지 않는 메모리
- 포인터가 아닌 값이 local variable에 저장되는 경우
  - 이 경우 고루틴의 스택을 활용한다.
  - 스택은 결국 함수와 생명주기를 함께 하기 때문에 컴파일러가 메모리 해제 시점을 사전에 결정할 수 있다.
  - 그렇기 때문에 메모리 할당과 해제 작업이 간단해진다
3. gc가 관리하는 메모리
- gc가 관리하는 메모리는 힙 영역에 저장되는것들
  - 메모리 할당과 해제 시점을 예측할 수 없는 것들
  - ex. 크기가 동적으로 결정되는 슬라이스의 배열 등.
  - ex. 이미 힙에 저장된 객체에 포인터로 참조되는 값.
  - 이러한 것들은 gc가 주기적으로 관찰하고 해제해야한다.
- 힙 메모리 영역은 결국 해제 시점이 명확하지 않으니 주기적으로 관찰해야하고 이게 성능에 영향을 미친다.
  - 다시 말하면 과도한 포인터 사용이 성능에 악영향을 줄 수 있고, 스택 메모리 사용이 좋은 경우도 있다는것
- 참고로 컴파일러는 걊이 스택에 남아도 되는지 Escape Analysis를 통해 힙으로 옮길지 결정한다
```
func example() *int {
    i := 42       // 스택에 할당될 가능성이 큼
    return &i     // i는 함수의 스코프를 벗어나므로 힙에 할당
}
```
4. Tracing Garbage Collection
- 기본적으로 go는 가비지 추적 방식을 사용한다.
  - 메모리 공간을 할당받은 object와 이 메모리 공간을 가르키는 주소인 포인터가 존재하는데
- 이러한 객체와 포인터의 object 그래프를 루트부터 시작하여 탐색한다
  - 그래프를 따라가면서 스캔하고, 더 이상 사용되지 않는 객체를 식별한다.
  - 사용중인 객체는 Mark해둔다
  - 이후 힙 영역 메모리를 모두 확인하여 Mark되지 않은 객체의 메모리 공간을 재사용할 수 있도록 sweep한다

5. gc cycle
- Sweep Phase (스윕 단계)
  - 실제로 청소하는 단계로, 이를 위해선 mark 작업이 선행되어야한다. 즉 모든 메모리가 추적되기 전까진 청소할 수 없다.
- Off Phase (비활성 단계)
  - gc와 관련없는 단계로, 정상적으로 애플리케이션이 실행되는 phase
- Mark Phase (마크 단계)
  - sweep 단계와 반드시 분리되어야하는데
  - 살아있는 객체를 식별하는 단계로, 모든 마킹이 완료되어야 청소가 가능하다
```
sweep - off - mark
```
6. gc cost
- 메모리 비용
  - live heap memory : 이전 gc 주기에서 사용중으로 판별된 영역. 실제 사용중으로 gc가 제어할 수 없다.
  - new heap memory : 현재 gc 주기동안 새로 할당된 메모리 공간. 다음 gc때 사용 여부를 판단
  - 메타데이터 : 위 두 메모리 공간에 비해 매우 작다. gc 메타데이터 저장용
- 메모리 비용 공식 : 
```
GC Memory Cost for Cycle N=Live Heap from Cycle N-1+New Heap
```
- cpu 비용
  - 고정 비용 : 각 gc마다 발생하는 일정한 작업으로 데이터 구조 초기화 작업 등으로 굉장히 작고 무시가능
  - 마진 비용 : live heap memory 영역 크기에 비례하는 cpu 비용. marking와 scanning에 사용되는 cpu 비용으로 gc의 주요 cpu 자원 사용 영역
- cpu 비용 공식 : 
```
GC CPU Time for Cycle N=Fixed Cost+(Average Cost per Byte×Live Heap)
```

7. gc 주기와 트레이드 오프
- GC 실행 빈도가 높아지면:
  - 메모리 사용량 감소: 더 자주 메모리를 회수하므로 힙 크기가 작아집니다.
  - CPU 오버헤드 증가: GC가 더 자주 실행되므로 CPU 자원을 더 많이 소비합니다.
- GC 실행 빈도가 낮아지면:
  - 메모리 사용량 증가: 회수되지 않은 메모리가 쌓여 힙 크기가 커집니다.
  - CPU 오버헤드 감소: GC 실행 횟수가 줄어 CPU 자원 소비가 감소합니다

8. GO GC
- go gc는 메모리와 cpu 균형을 맞추고자하는데
  - 매 gc 사이클 이후 다음 target heap size를 결정해서 동작한다
  - 그 방식은 `Target heap memory = Live heap + (Live heap + GC roots) * GOGC / 100`
```
Live Heap = 8 MiB, goroutine 스택 = 1 MiB, 글로벌 변수 포인터 = 1 MiB인 경우

GOGC = 100일 때:
Target heap size = 8 + (8 + 2) * 100 / 100 = 8 + 10 = 18 MiB

참고로 gc roots란 전역변수나 고루틴 스택 등
- gogc default : 100
```
- memory limit을 설정할 수 있는데 이 설정은 기본적으로 soft다.
  - 당연하게도 메모리 부족은 애플리케이션의 중단으로 이어지기 때문이다.
 
9. latency
- go gc는 기본적으로 stop-the-world gc가 아니라 애플리케이션 실행과 병렬적으로 처리된다
  - 물론 기본적으로 stop the world 시간 자체는 존재한다
    - Mark와 Sweep 단계 사이의 전환 시점.
    - Goroutines의 Root Scanning 단계(각 goroutine의 메모리 루트 확인).
- 이 latency를 줄이기 위한 노력으론
  - mark 시점에 전체 cpu 중 25%만 사용하여 나머지는 애플리케이션 동작을 위해 사용된다
    - 이로인해 gc가 느려질 가능성도, 애플리케이션 throughput에 영향을 줄 순 있다.
  - 만약 높은 메모리 할당 속도가 포착되면, gc는 사용자의 고루틴을 일부 사용하여 일부 gc 작업을 수행한다.
  - pointer writer
    - mark 단계에서 새롭게 객체가 생성되어 메모리 공간을 할당받을 수 있는데 놓칠 수 있다
    - 그래서 gc는 mark 단계에서 write barrier를 통해 새로운 객체를 감시하고 변경된 포인터등을 추적하여 마킹하고 잘못 지우지 않도록 한다.
    
